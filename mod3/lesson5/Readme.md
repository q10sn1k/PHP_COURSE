# Использование статических свойств и методов в PHP

В PHP 8.0 статические свойства и методы позволяют создавать данные и функции, которые будут доступны на уровне класса, а не на уровне экземпляров объектов класса.\
Это означает, что статические свойства и методы могут использоваться без создания экземпляра класса.

Статические свойства и методы объявляются с использованием ключевого слова "static".\
Статические свойства доступны через оператор "::", а статические методы могут быть вызваны также через оператор "::".

## Преимущества использования статических свойств и методов:

### Экономия памяти:

Статические свойства используются на уровне класса, а не на уровне объектов, поэтому они занимают меньше памяти.

### Удобство использования:

Статические методы и свойства могут использоваться без создания экземпляра класса, что делает их удобными для быстрого доступа к определенным данным и функциям.


Статические свойства и методы очень полезны  и могут существенно упростить программирование, особенно при работе с большим количеством объектов одного класса.


Статические методы и свойства принадлежат классу, а не объекту. \
Статические методы могут быть использованы без создания экземпляра класса, а доступ к ним осуществляется через имя класса.

Для объявления статического свойства или метода используется ключевое слово "static".\
Оно должно быть указано перед объявлением свойства или метода.

```php
<?php

class User {
    private static int $count = 0;

    public static function getCount(): int {
        return self::$count;
    }

    public function __construct() {
        self::$count++;
    }
}

$user1 = new User();
$user2 = new User();
$user3 = new User();

echo User::getCount(); // Выводит 3

```

Мы объявляем статическое свойство $count, которое используется для подсчета количества созданных объектов класса User.\
Также объявляем статический метод getCount(), который возвращает количество созданных объектов.

В конструкторе класса мы увеличиваем значение $count при создании нового объекта. \
Затем мы можем получить количество созданных объектов, вызвав статический метод getCount() через имя класса.

Использование статических свойств и методов может быть полезно, когда нам нужно получить общую информацию для всех экземпляров класса, или когда нам нужно использовать метод, который не зависит от состояния объекта.

Важно отметить, что статические методы и свойства не могут использовать нестатические свойства и методы класса, так как они не принадлежат конкретному объекту.

___________________

Реализуем класс Rectangle, у которого будет статическое свойство count для подсчета количества созданных объектов этого класса,\
а также методы getArea и getPerimeter для вычисления площади и периметра прямоугольника соответственно.

```php
// Абстрактный класс фигуры
abstract class Figure {
  abstract public function getArea(): float;
  abstract public function getPerimeter(): float;
}

// Класс прямоугольника, наследуемый от абстрактного класса Figure
class Rectangle extends Figure {
  private float $width;
  private float $height;
  private static int $count = 0;

  public function __construct(float $width, float $height) {
    $this->width = $width;
    $this->height = $height;
    self::$count++; // увеличиваем счетчик объектов при каждом создании экземпляра
  }

  public function getArea(): float {
    return $this->width * $this->height;
  }

  public function getPerimeter(): float {
    return 2 * ($this->width + $this->height);
  }

  public static function getCount(): int { // статический метод для получения количества созданных объектов
    return self::$count;
  }
}

// Создаем объекты прямоугольников
$rectangle1 = new Rectangle(5, 10);
$rectangle2 = new Rectangle(7, 3);

// Выводим площади и периметры прямоугольников
echo "Площадь прямоугольника 1: " . $rectangle1->getArea() . "<br>";
echo "Периметр прямоугольника 1: " . $rectangle1->getPerimeter() . "<br>";
echo "Площадь прямоугольника 2: " . $rectangle2->getArea() . "<br>";
echo "Периметр прямоугольника 2: " . $rectangle2->getPerimeter() . "<br>";

// Выводим количество созданных объектов
echo "Количество созданных объектов: " . Rectangle::getCount() . "<br>"; // статический метод вызываем у класса, а не у объекта
```


Реализуем класс Person, у которого будет статическое свойство count для подсчета количества созданных объектов этого класса, а также метод getInfo для получения информации о персоне.


```php
<?php
class Person {
  // Статическое свойство для подсчета количества созданных объектов
  private static int $count = 0;

  private string $name;
  private int $age;

  public function __construct(string $name, int $age) {
    $this->name = $name;
    $this->age = $age;
    // При создании нового объекта инкрементируем статическое свойство count
    self::$count++;
  }

  public static function getCount(): int {
    return self::$count;
  }

  public function getInfo(): string {
    return "Имя: {$this->name}, Возраст: {$this->age}";
  }
}

// Создаем несколько объектов класса Person
$person1 = new Person("Иван", 25);
$person2 = new Person("Анна", 30);

// Выводим информацию о каждом объекте
echo $person1->getInfo() . "<br>";
echo $person2->getInfo() . "<br>";

// Выводим количество созданных объектов
echo "Количество созданных объектов: " . Person::getCount() . "<br>";

```

Реализуйем класс Car, у которого будет статическое свойство count для подсчета количества созданных объектов этого класса, а также методы start и stop для запуска и остановки двигателя соответственно.

```php
<?php

abstract class Car {
  protected bool $engineStarted = false;

  // Статическое свойство для подсчета количества созданных объектов
  protected static int $count = 0;

  public function __construct() {
    // Увеличиваем счетчик при создании нового объекта
    static::$count++;
  }

  public function startEngine(): void {
    $this->engineStarted = true;
    echo "Двигатель запущен" . "<br>";
  }

  public function stopEngine(): void {
    $this->engineStarted = false;
    echo "Двигатель остановлен" . "<br>";
  }

  // Статический метод для получения количества созданных объектов
  public static function getCount(): int {
    return static::$count;
  }
}

// Класс для электромобиля
class ElectricCar extends Car {
  public function startEngine(): void {
    parent::startEngine();
    echo "Аккумулятор заряжен" . "<br>";
  }

  public function stopEngine(): void {
    parent::stopEngine();
    echo "Аккумулятор разряжен" . "<br>";
  }
}

// Класс для автомобиля с двигателем внутреннего сгорания
class GasolineCar extends Car {
  public function startEngine(): void {
    parent::startEngine();
    echo "Заправлен бензин" . "<br>";
  }

  public function stopEngine(): void {
    parent::stopEngine();
    echo "Бензин закончился" . "<br>";
  }
}

// Создаем объекты автомобилей
$electricCar = new ElectricCar();
$gasolineCar = new GasolineCar();

// Запускаем и останавливаем двигатель каждого автомобиля
$electricCar->startEngine();
$electricCar->stopEngine();

$gasolineCar->startEngine();
$gasolineCar->stopEngine();

// Выводим количество созданных объектов
echo "Количество созданных автомобилей: " . Car::getCount() . "<br>";

```
______________________________
______________________________
______________________________

# Домашнее задание

## Задача 1

Реализуйте класс Calculator, у которого будут статические методы для выполнения основных математических операций: add, subtract, multiply и divide. \
Каждый метод должен принимать два аргумента и возвращать результат вычисления.

## Задача 2

Реализуйте класс BankAccount, у которого будет статическое свойство interestRate для хранения процентной ставки по счету, а также методы setInterestRate и getInterestRate для установки и получения значения процентной ставки соответственно.

## Задача 3

Реализуйте класс Book,  у которого будет статическое свойство count для подсчета количества созданных объектов этого класса, а также метод getInfo для получения информации о книге.